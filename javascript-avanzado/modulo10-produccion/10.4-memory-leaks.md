# 10.4 Memory Leaks en JavaScript

## 🧠 ¿Qué es un Memory Leak?

Un **memory leak (fuga de memoria)** ocurre cuando un programa **reserva memoria pero nunca la libera**, ocupando cada vez más RAM sin necesitarla.
Aunque JavaScript tiene **garbage collector automático**, **sí puede haber fugas de memoria** si el código mantiene referencias innecesarias.

---

## ⚠️ ¿Por qué es peligroso?

Porque provoca:
❌ Lentitud en la app
❌ Bloqueos
❌ Navegadores congelados
❌ Mala experiencia de usuario

---

## 🔥 Causas comunes de memory leaks

### 1. Variables globales innecesarias

```js
leak = []; // sin let/const → se vuelve global
```

---

### 2. Referencias no limpiadas

```js
let lista = document.querySelectorAll("li");
// ...más tarde
lista = null; // liberar referencia cuando ya no se usa
```

---

### 3. Event listeners no eliminados

```js
function saludar() {
  console.log("Hola");
}
button.addEventListener("click", saludar);
// Si no eliminas esto puede acumularse:
button.removeEventListener("click", saludar);
```

---

### 4. Timers sin limpiar

```js
const id = setInterval(() => console.log("Hola"), 1000);
// ...
clearInterval(id); // siempre limpiar
```

---

### 5. Closures mal usados

```js
function crearLeak() {
  const datosPesados = new Array(1000000).fill("😵");
  return () => console.log("usando closure");
}
const leakFunc = crearLeak(); // datosPesados nunca se libera
```

---

## ✅ Buenas prácticas para evitar fugas

✔ Usa `let` y `const` siempre
✔ Limpia listeners con `removeEventListener`
✔ Limpia timers con `clearTimeout` o `clearInterval`
✔ Evita acumular datos en arrays sin límite
✔ Usa herramientas de monitorización (Chrome DevTools → Memory)

---

# 🛠 Laboratorio

## 🎯 Objetivos

* Detectar fugas de memoria comunes
* Evitar referencias innecesarias
* Limpiar listeners y timers correctamente

---

### Ejercicio 1 — Código con fuga

Encuentra el problema:

```js
setInterval(() => console.log("Hola"), 1000);
```

Solución:

```js
const id = setInterval(() => console.log("Hola"), 1000);
// ...
clearInterval(id);
```

---

### Ejercicio 2 — Listener sin limpiar

```js
function handler() {
  console.log("click");
}
btn.addEventListener("click", handler);
// ...
btn.removeEventListener("click", handler);
```

---

### Ejercicio 3 — Evitar variables globales

❌ Mal

```js
contador = 0;
```

✅ Bien

```js
let contador = 0;
```

---

### Ejercicio 4 — Referencias grandes

```js
let buffer = new Array(1000000).fill(0);
// ...
buffer = null; // liberar memoria
```

---

### Ejercicio 5 — Detectar problema real

```js
function fuga() {
  let data = [];
  return () => data.push(Date.now());
}
const f = fuga();
// cada llamada aumenta memoria
```

---

## 🚀 Retos

1. Crea una función que registre eventos, pero asegúrate de limpiarlos tras usarlos.
2. Haz un temporizador "seguro" que pueda iniciarse y detenerse sin filtrar memoria.
3. Simula un leak y encuentra cómo corregirlo usando herramientas de "Performance" del navegador.