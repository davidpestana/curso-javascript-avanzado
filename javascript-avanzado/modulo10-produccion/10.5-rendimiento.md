Aquí tienes **10.5 – Ajuste de rendimiento en JavaScript (Performance Tuning)**. Este tema enseña técnicas reales para optimizar la velocidad y eficiencia del código. Muy útil en producción ⚡

---

# 10.5 Ajuste de rendimiento (Performance Tuning)

## 🚀 ¿Por qué optimizar?

Cuanto más grande es una aplicación, más importante es que funcione rápido.
El rendimiento afecta:
✅ UX (experiencia de usuario)
✅ Conversión en webs
✅ Consumo de batería en móviles
✅ Posicionamiento SEO

---

## ⚙️ Principios clave

* **No optimices antes de medir**
* Evita **cálculos innecesarios**
* Reduce **accesos al DOM** (son costosos)
* Evita **bucles pesados**
* Usa **estructuras eficientes** (`Map`, `Set`, etc.)

---

## ✅ Técnicas esenciales

### 1. Minimizar trabajo dentro de bucles

```js
// ❌ Mal
for (let i = 0; i < arr.length; i++) console.log(arr[i]);

// ✅ Mejor
for (const item of arr) console.log(item);
```

---

### 2. Usar caché o memoización

```js
const cache = {};
function cuadrado(n) {
  if (cache[n]) return cache[n];
  cache[n] = n * n;
  return cache[n];
}
```

---

### 3. Evitar accesos innecesarios al DOM

```js
// ❌ Evitar recalcular elemento cada vez
for (let i = 0; i < 1000; i++) {
  document.getElementById("contador").textContent = i;
}

// ✅ Mejor → guardar referencia
const c = document.getElementById("contador");
for (let i = 0; i < 1000; i++) c.textContent = i;
```

---

### 4. Debounce y throttle

Para evitar que funciones se ejecuten muchas veces en poco tiempo.

**Debounce (esperar a que termine de escribir, por ejemplo):**

```js
function debounce(fn, delay) {
  let id;
  return (...args) => {
    clearTimeout(id);
    id = setTimeout(() => fn(...args), delay);
  };
}
```

**Throttle (limitar velocidad de ejecución):**

```js
function throttle(fn, limit) {
  let esperando = false;
  return (...args) => {
    if (!esperando) {
      fn(...args);
      esperando = true;
      setTimeout(() => (esperando = false), limit);
    }
  };
}
```

---

### 5. Usar estructuras rápidas

```js
const set = new Set([1, 2, 2, 3]); // elimina duplicados
set.has(2);  // rápido
```

---

# 🛠 Laboratorio

## 🎯 Objetivos

* Detectar código lento
* Usar técnicas básicas de optimización
* Reducir operaciones innecesarias

---

### Ejercicio 1 — Guardar referencia

```js
const titulo = document.getElementById("titulo");
// reutilizar 'titulo' en vez de buscarlo cada vez
```

---

### Ejercicio 2 — Optimizar bucles

```js
const lista = [1, 2, 3, 4, 5];
for (const item of lista) {
  console.log(item);
}
```

---

### Ejercicio 3 — Eliminando duplicados

```js
const nums = [1, 2, 2, 3, 4, 4];
const unicos = [...new Set(nums)];
```

---

### Ejercicio 4 — Debounce en buscador

```js
const buscador = document.getElementById("buscar");
const buscar = debounce((txt) => console.log("Buscando:", txt), 500);

buscador.addEventListener("input", e => buscar(e.target.value));
```

---

### Ejercicio 5 — Throttle en scroll

```js
window.addEventListener("scroll", throttle(() => {
  console.log("Scroll detectado");
}, 1000));
```

---

## 🚀 Retos

1. Optimiza una función pesada usando memoización.
2. Reduce los reflows del DOM agrupando cambios.
3. Usa `performance.now()` para medir el tiempo que tarda en ejecutarse una función.