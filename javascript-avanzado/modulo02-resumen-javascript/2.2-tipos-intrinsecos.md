# 2.2 Tipos intr√≠nsecos de los objetos

## üß© ¬øQu√© son los tipos por referencia?

En JavaScript, **casi todo es un objeto**. Aunque existen tipos primitivos, la mayor√≠a de estructuras m√°s √∫tiles (como arrays, funciones, fechas y mapas) son objetos especiales.

```js
const persona = { nombre: "Ada", edad: 34 };  // Object
const lista = [1, 2, 3];                      // Array (un tipo de objeto)
function saludar() {}                         // Function (tambi√©n es objeto)
const hoy = new Date();                       // Date
const conjunto = new Set([1, 2, 3]);          // Set
const mapa = new Map([["id", 123]]);          // Map
```

---

## üß≠ Diferencia clave: valor vs referencia

Los **primitivos se copian por valor**, mientras que **los objetos se copian por referencia**. Eso significa que dos variables pueden apuntar al mismo objeto en memoria.

```js
const original = { nombre: "Ada" };
const copia = original;

copia.nombre = "Alan";

console.log(original.nombre); // "Alan" üò±
```

Modificar `copia` tambi√©n modific√≥ `original`, porque **ambas apuntan al mismo objeto**.

---

## ‚úÖ Comparaci√≥n de objetos

Comparar objetos con `===` no compara contenido, compara referencia.

```js
const a = { x: 1 };
const b = { x: 1 };
a === b; // false ‚ùå (aunque tengan el mismo contenido)
const c = a;
a === c; // true ‚úÖ (misma referencia)
```

---

## üîß Comprobando tipos de objetos

`typeof` NO es suficiente para detectar tipos de objetos. Debemos usar herramientas espec√≠ficas:

```js
Array.isArray([]);                 // true
typeof [] === "object";            // true pero poco informativo
```

Detectar tipos correctamente:

```js
typeof {}                     // "object"
typeof []                     // "object"
Array.isArray([])             // true ‚úÖ
typeof function(){}           // "function"
```

---

## ‚úã Mutabilidad

Los objetos se pueden modificar incluso si est√°n declarados con `const`:

```js
const usuario = { nombre: "Ada" };
usuario.nombre = "Alan"; // ‚úÖ permitido
// usuario = {}          // ‚ùå NO se puede reasignar la referencia
```

---

# üõ† Laboratorio

## üéØ Objetivos

* Entender c√≥mo funcionan las referencias en memoria
* Detectar correctamente arrays y objetos
* Ver qu√© pasa al copiar objetos
* Evitar comparar objetos por contenido de forma incorrecta

---

### Ejercicio 1 ‚Äî Copia por referencia

1. Declara `const a = { x: 10 }`
2. Crea `const b = a`
3. Cambia b.x a 20
4. Muestra a.x

Resultado esperado: **20** (porque comparten referencia).

```js
const a = { x: 10 };
const b = a;
b.x = 20;
console.log(a.x); // 20
```

---

### Ejercicio 2 ‚Äî Copia segura (shallow copy)

1. Crea `const original = { nombre: "Ada", edad: 36 }`
2. Haz una copia independiente con spread `{...original}`
3. Cambia la copia y verifica que el original no cambia

```js
const original = { nombre: "Ada", edad: 36 };
const copia = { ...original };
copia.nombre = "Alan";
console.log(original.nombre); // "Ada"
```

---

### Ejercicio 3 ‚Äî Detectar arrays correctamente

1. Comprueba si cada valor es un array:
   [], {}, "hola", [1, 2], new Array()

```js
Array.isArray([]);          // true
Array.isArray({});          // false
Array.isArray("hola");      // false
Array.isArray([1, 2]);      // true
Array.isArray(new Array()); // true
```

---

### Ejercicio 4 ‚Äî Comparaci√≥n de objetos

1. Compara `{ x: 1 } === { x: 1 }`
2. Compara dos objetos apuntando al mismo sitio

```js
{ x: 1 } === { x: 1 }; // false
const obj1 = { y: 2 };
const obj2 = obj1;
obj1 === obj2; // true
```

---

### Ejercicio 5 ‚Äî Congelar objetos

Evita que un objeto sea modificado usando `Object.freeze`

```js
const config = Object.freeze({ modo: "producci√≥n" });
config.modo = "debug"; // ignorado
console.log(config.modo); // "producci√≥n"
```

---

## üöÄ Retos

1. Crea una funci√≥n `clonar(obj)` que haga una copia profunda (deep copy) sin usar librer√≠as.
2. Crea una funci√≥n `mismoContenido(a, b)` que compare si dos objetos tienen el mismo contenido (sin comparar referencia).
3. Explica cu√°ndo usar√≠as `Map` y `Set` en vez de objetos planos `{}` o arrays `[]`.