# 7.2 Promises (Promesas)

## 💡 ¿Qué es una Promesa?

Una **promesa** representa una operación que **todavía no ha terminado**, pero que lo hará en el futuro.
Sirve para **reemplazar los callbacks anidados** y hacer el código asincrónico más limpio y legible.

Piensa en una promesa como un “vale”:

> “Prometo devolverte algo… pero todavía no lo tengo”.

---

## 🔧 Sintaxis básica

```js
const promesa = new Promise((resolve, reject) => {
  // operación asincrónica
  const exito = true;
  if (exito) resolve("Todo bien ✅");
  else reject("Algo falló ❌");
});
```

Las promesas tienen **3 estados**:

1. *pending* (pendiente)
2. *fulfilled* (resuelta con éxito)
3. *rejected* (rechazada por error)

---

## ✅ Consumir una promesa

Se usan los métodos `.then()` y `.catch()` para reaccionar al resultado.

```js
promesa
  .then(resultado => console.log("Éxito:", resultado))
  .catch(error => console.log("Error:", error));
```

---

## 🧠 Ejemplo completo

```js
const obtenerUsuario = new Promise((resolve, reject) => {
  setTimeout(() => {
    const ok = Math.random() > 0.3;
    if (ok) resolve({ nombre: "Ada", edad: 36 });
    else reject("No se pudo obtener el usuario");
  }, 1000);
});

obtenerUsuario
  .then(usuario => console.log("Usuario:", usuario))
  .catch(error => console.log("Error:", error));
```

---

## 🔗 Encadenar promesas

Las promesas se pueden encadenar para ejecutar varias operaciones en orden, sin el “infierno de callbacks”.

```js
function paso1() {
  return Promise.resolve("Paso 1 completado");
}

function paso2() {
  return Promise.resolve("Paso 2 completado");
}

paso1()
  .then(resultado => {
    console.log(resultado);
    return paso2();
  })
  .then(resultado => console.log(resultado))
  .catch(error => console.log("Error:", error));
```

---

## ⚡ Promise.all

Ejecuta varias promesas en paralelo y espera que **todas terminen**.

```js
const p1 = Promise.resolve("Tarea 1");
const p2 = Promise.resolve("Tarea 2");
const p3 = Promise.resolve("Tarea 3");

Promise.all([p1, p2, p3]).then(res => console.log(res));
// ["Tarea 1", "Tarea 2", "Tarea 3"]
```

---

# 🛠 Laboratorio

## 🎯 Objetivos

* Crear y resolver promesas
* Manejar errores con catch
* Encadenar promesas correctamente
* Evitar el “callback hell”

---

### Ejercicio 1 — Promesa simple

Crea una promesa que se resuelva después de 2 segundos.

```js
const miPromesa = new Promise((resolve) => {
  setTimeout(() => resolve("Promesa cumplida 🎉"), 2000);
});

miPromesa.then(mensaje => console.log(mensaje));
```

---

### Ejercicio 2 — Promesa con error

Simula un fallo aleatorio.

```js
const promesaAleatoria = new Promise((resolve, reject) => {
  const exito = Math.random() > 0.5;
  exito ? resolve("Todo salió bien 😎") : reject("Ups, falló 😢");
});

promesaAleatoria
  .then(r => console.log("OK:", r))
  .catch(e => console.log("Error:", e));
```

---

### Ejercicio 3 — Promesas encadenadas

```js
function pasoA() {
  return Promise.resolve("Paso A listo");
}
function pasoB() {
  return Promise.resolve("Paso B listo");
}
pasoA()
  .then(m => { console.log(m); return pasoB(); })
  .then(m => console.log(m))
  .catch(e => console.log("Error:", e));
```

---

### Ejercicio 4 — Promise.all

```js
const fetch1 = Promise.resolve("Datos 1");
const fetch2 = Promise.resolve("Datos 2");
const fetch3 = Promise.resolve("Datos 3");

Promise.all([fetch1, fetch2, fetch3])
  .then(res => console.log("Todo listo:", res));
```

---

### Ejercicio 5 — Manejo de error real

```js
function obtenerDatos(url) {
  return new Promise((resolve, reject) => {
    if (!url.startsWith("http")) reject("URL inválida");
    else setTimeout(() => resolve("Datos cargados ✅"), 1000);
  });
}

obtenerDatos("https://api.ejemplo.com")
  .then(console.log)
  .catch(console.error);
```

---

## 🚀 Retos

1. Crea una función `esperar(ms)` que devuelva una promesa que se resuelva tras ms milisegundos.
2. Simula una llamada a API con 3 pasos encadenados (`login → obtener datos → mostrar datos`).
3. Usa `Promise.all` para esperar varias operaciones a la vez y mostrar los resultados juntos.

