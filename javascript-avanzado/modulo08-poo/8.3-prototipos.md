# 8.3 Prototipos

## üß¨ ¬øQu√© es un prototipo?

En JavaScript, todos los objetos tienen un **prototipo**, que es como un "objeto padre" del que **heredan propiedades y m√©todos**.
Cuando intentas acceder a una propiedad que no est√° en el objeto, **JavaScript la busca en su prototipo**, luego en el prototipo del prototipo... hasta llegar al final (cadena de prototipos o ‚Äúprototype chain‚Äù).

---

## üß± Ejemplo simple

```js
const persona = {
  nombre: "Ana",
  saludar() {
    console.log("Hola, soy " + this.nombre);
  }
};

persona.saludar(); // Hola, soy Ana
```

Por debajo, este objeto **hereda** m√©todos del prototipo base **Object**, como `.toString()`, `.hasOwnProperty()`, etc.

---

## üèóÔ∏è Prototipo en funciones constructoras

Cada funci√≥n constructora tiene una propiedad `.prototype` que permite **a√±adir m√©todos compartidos** entre todas las instancias.

```js
function Persona(nombre) {
  this.nombre = nombre;
}

// A√±adimos m√©todo al prototipo (mejor que dentro del constructor)
Persona.prototype.saludar = function () {
  console.log("Hola, soy " + this.nombre);
};

const p1 = new Persona("Ada");
const p2 = new Persona("Alan");

p1.saludar(); // Hola, soy Ada
p2.saludar(); // Hola, soy Alan
```

‚úÖ Ventaja: el m√©todo se comparte y no se duplica en cada objeto ‚Üí **mejor rendimiento**.

---

## üîó Cadena de prototipos (prototype chain)

```js
p1.__proto__ === Persona.prototype          // true
Persona.prototype.__proto__ === Object.prototype // true
Object.prototype.__proto__ === null         // final de la cadena
```

---

## ‚öôÔ∏è Propiedades propias vs heredadas

```js
p1.hasOwnProperty("nombre");  // true (propia)
p1.hasOwnProperty("saludar"); // false (heredada del prototipo)
```

---

## ‚úèÔ∏è Crear prototipos manualmente (Object.create)

```js
const animal = {
  hablar() {
    console.log("Hago sonidos...");
  }
};

const perro = Object.create(animal); // hereda de animal
perro.hablar(); // Hago sonidos...
```

---

# üõ† Laboratorio

## üéØ Objetivos

* Entender c√≥mo funciona `.prototype`
* A√±adir m√©todos compartidos
* Diferenciar propiedades propias vs heredadas
* Usar la cadena de prototipos correctamente

---

### Ejercicio 1 ‚Äî M√©todo en prototype

A√±ade un m√©todo al prototipo de Persona.

```js
function Persona(nombre) {
  this.nombre = nombre;
}

Persona.prototype.saludar = function () {
  console.log("Hola, soy " + this.nombre);
};

const p = new Persona("Lucas");
p.saludar();
```

---

### Ejercicio 2 ‚Äî M√∫ltiples m√©todos compartidos

```js
Persona.prototype.despedir = function () {
  console.log(this.nombre + " dice adi√≥s üëã");
};
const p2 = new Persona("Elena");
p2.despedir();
```

---

### Ejercicio 3 ‚Äî Diferenciar propiedades

```js
p.hasOwnProperty("nombre");  // true
p.hasOwnProperty("saludar"); // false
```

---

### Ejercicio 4 ‚Äî Herencia con Object.create

```js
const vehiculo = { tipo: "Gen√©rico" };
const coche = Object.create(vehiculo);
coche.ruedas = 4;

console.log(coche.tipo); // Heredada
console.log(coche.ruedas); // Propia
```

---

### Ejercicio 5 ‚Äî Comprobar cadena de prototipos

```js
console.log(Object.getPrototypeOf(p) === Persona.prototype); // true
console.log(Object.getPrototypeOf(Persona.prototype) === Object.prototype); // true
```

---

## üöÄ Retos

1. Crea un prototipo `Figura` con m√©todo `area()` y her√©dalo en `Rectangulo`.
2. A√±ade al prototipo de `Array` un m√©todo personalizado `.primero()` que devuelva el primer elemento.
3. Explica con c√≥digo c√≥mo JavaScript busca una propiedad en la cadena de prototipos.